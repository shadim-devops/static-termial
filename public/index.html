<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Linux Terminal</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #00ff00;
            --prompt-color: #00aaff;
            --error-color: #ff5555;
            --header-bg: #2d2d2d;
            --border-color: #444;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .terminal-header {
            background-color: var(--header-bg);
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .terminal-title {
            font-weight: bold;
        }
        
        .terminal-controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .close { background-color: #ff5f56; }
        .minimize { background-color: #ffbd2e; }
        .maximize { background-color: #27ca3f; }
        
        .terminal-body {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .output-line {
            margin-bottom: 5px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .command-line {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .prompt {
            color: var(--prompt-color);
            margin-right: 8px;
            white-space: nowrap;
        }
        
        .command-input {
            background: transparent;
            border: none;
            color: var(--text-color);
            outline: none;
            flex: 1;
            font-size: 16px;
        }
        
        .error {
            color: var(--error-color);
        }
        
        .file {
            color: #ffffff;
        }
        
        .directory {
            color: #87ceeb;
        }
        
        .executable {
            color: #ffa500;
        }
        
        .welcome-message {
            margin-bottom: 15px;
            color: #aaa;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2d2d2d;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .terminal-body {
                padding: 10px;
            }
            
            .command-input {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-header">
        <div class="terminal-title">Static Linux Terminal</div>
        <div class="terminal-controls">
            <div class="control-btn close" onclick="closeTerminal()"></div>
            <div class="control-btn minimize" onclick="minimizeTerminal()"></div>
            <div class="control-btn maximize" onclick="maximizeTerminal()"></div>
        </div>
    </div>
    
    <div class="terminal-body" id="terminal-output">
        <div class="welcome-message">
            Welcome to Static Linux Terminal (v1.0)<br>
            This is a browser-based simulation of a Linux terminal.<br>
            Type 'help' to see available commands.
        </div>
        <div class="output-line">Last login: Fri Oct 27 14:30:00 on ttys000</div>
    </div>
    
    <div class="command-line">
        <span class="prompt" id="current-prompt">user@static-terminal:~$</span>
        <input type="text" class="command-input" id="command-input" autofocus>
    </div>

    <script>
        // File system simulation
        const fileSystem = {
            'home': {
                'user': {
                    'Documents': {
                        'README.txt': 'Welcome to the static terminal project!',
                        'project': {
                            'src': {
                                'main.js': 'console.log("Hello World");'
                            },
                            'package.json': '{"name": "static-terminal"}'
                        }
                    },
                    'Downloads': {
                        'archive.tar.gz': 'Compressed file content'
                    },
                    '.bashrc': 'export PATH=$PATH:/usr/local/bin',
                    '.hidden_file': 'This is a hidden file'
                }
            },
            'etc': {
                'passwd': 'root:x:0:0:root:/root:/bin/bash\nuser:x:1000:1000:User,,,:/home/user:/bin/bash',
                'hosts': '127.0.0.1 localhost'
            },
            'var': {
                'log': {
                    'syslog': 'System log content'
                }
            },
            'bin': {
                'ls': 'executable',
                'bash': 'executable'
            }
        };

        // Current directory state
        let currentPath = ['home', 'user'];
        let commandHistory = [];
        let historyIndex = -1;

        // DOM elements
        const terminalOutput = document.getElementById('terminal-output');
        const commandInput = document.getElementById('command-input');
        const currentPrompt = document.getElementById('current-prompt');

        // Initialize the terminal
        function initTerminal() {
            updatePrompt();
            commandInput.focus();
            
            // Add event listeners
            commandInput.addEventListener('keydown', handleKeyDown);
            commandInput.addEventListener('input', handleInput);
            
            // Prevent right-click context menu
            document.addEventListener('contextmenu', e => e.preventDefault());
        }

        // Update the prompt based on current directory
        function updatePrompt() {
            const path = currentPath.length > 2 ? 
                '~/' + currentPath.slice(2).join('/') : 
                currentPath.join('/');
            currentPrompt.textContent = `user@static-terminal:${path}$`;
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            if (e.key === 'Enter') {
                executeCommand(commandInput.value.trim());
                commandInput.value = '';
                historyIndex = -1;
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0) {
                    if (historyIndex === -1) {
                        historyIndex = commandHistory.length - 1;
                    } else if (historyIndex > 0) {
                        historyIndex--;
                    }
                    commandInput.value = commandHistory[historyIndex] || '';
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    commandInput.value = commandHistory[historyIndex] || '';
                } else {
                    historyIndex = -1;
                    commandInput.value = '';
                }
            } else if (e.key === 'Tab') {
                e.preventDefault();
                autoComplete(commandInput.value);
            }
        }

        // Handle input for real-time features
        function handleInput() {
            // Could add real-time suggestions here
        }

        // Execute a command
        function executeCommand(cmd) {
            if (!cmd) {
                addOutput('', 'command-line');
                return;
            }
            
            // Add command to history
            if (commandHistory[commandHistory.length - 1] !== cmd) {
                commandHistory.push(cmd);
            }
            
            // Display the command
            addOutput(currentPrompt.textContent + ' ' + cmd, 'output-line');
            
            // Parse and execute
            const parts = cmd.split(' ').filter(part => part.length > 0);
            const command = parts[0];
            const args = parts.slice(1);
            
            try {
                // Execute the appropriate command function
                if (command in commands) {
                    commands[command](args);
                } else {
                    addOutput(`bash: ${command}: command not found`, 'output-line error');
                }
            } catch (error) {
                addOutput(`Error: ${error.message}`, 'output-line error');
            }
            
            // Scroll to bottom
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        // Add output to the terminal
        function addOutput(text, className = 'output-line') {
            const line = document.createElement('div');
            line.className = className;
            line.textContent = text;
            terminalOutput.appendChild(line);
        }

        // Auto-complete function
        function autoComplete(input) {
            const parts = input.split(' ');
            const lastPart = parts[parts.length - 1];
            
            if (lastPart.includes('/')) {
                // Path completion
                const pathParts = lastPart.split('/');
                const dirPart = pathParts.slice(0, -1).join('/');
                const filePart = pathParts[pathParts.length - 1];
                
                const dir = navigateToPath(dirPart || '.');
                if (dir && typeof dir === 'object') {
                    const matches = Object.keys(dir).filter(name => 
                        name.startsWith(filePart)
                    );
                    
                    if (matches.length === 1) {
                        parts[parts.length - 1] = dirPart ? 
                            `${dirPart}/${matches[0]}` : matches[0];
                        commandInput.value = parts.join(' ');
                    } else if (matches.length > 1) {
                        addOutput(matches.join('  '), 'output-line');
                    }
                }
            } else {
                // Command completion
                const matches = Object.keys(commands).filter(cmd => 
                    cmd.startsWith(lastPart)
                );
                
                if (matches.length === 1) {
                    parts[parts.length - 1] = matches[0];
                    commandInput.value = parts.join(' ');
                } else if (matches.length > 1) {
                    addOutput(matches.join('  '), 'output-line');
                }
            }
        }

        // Navigate to a path in the file system
        function navigateToPath(path) {
            if (path === '.' || path === '') {
                return getCurrentDir();
            }
            
            if (path === '..') {
                return navigateUp();
            }
            
            if (path.startsWith('/')) {
                // Absolute path
                const pathParts = path.split('/').filter(p => p);
                let current = fileSystem;
                
                for (const part of pathParts) {
                    if (current && current[part] && typeof current[part] === 'object') {
                        current = current[part];
                    } else {
                        return null;
                    }
                }
                
                return current;
            } else {
                // Relative path
                const pathParts = path.split('/').filter(p => p);
                let current = getCurrentDir();
                
                for (const part of pathParts) {
                    if (current && current[part] && typeof current[part] === 'object') {
                        current = current[part];
                    } else {
                        return null;
                    }
                }
                
                return current;
            }
        }

        // Get current directory object
        function getCurrentDir() {
            let current = fileSystem;
            for (const dir of currentPath) {
                current = current[dir];
            }
            return current;
        }

        // Navigate up one directory
        function navigateUp() {
            if (currentPath.length > 1) {
                currentPath.pop();
                updatePrompt();
                return getCurrentDir();
            }
            return fileSystem;
        }

        // Command implementations
        const commands = {
            help: () => {
                addOutput('Available commands:', 'output-line');
                addOutput('  help, clear, echo, date, uname, uname -a, lscpu', 'output-line');
                addOutput('  pwd, ls, ls -l, ls -la, cd, touch, mkdir, rm', 'output-line');
                addOutput('  cp, mv, ln, ln -s, uptime, free, top', 'output-line');
                addOutput('  ip addr, ifconfig, ping, cat, grep, find, ps', 'output-line');
                addOutput('  whoami, id, groups, sudo, chmod, chown, df, du', 'output-line');
                addOutput('  useradd, passwd, cat /etc/passwd, exit', 'output-line');
            },
            
            clear: () => {
                terminalOutput.innerHTML = '';
            },
            
            pwd: () => {
                addOutput('/' + currentPath.join('/'), 'output-line');
            },
            
            ls: (args) => {
                const showDetails = args.includes('-l') || args.includes('-la');
                const showAll = args.includes('-a') || args.includes('-la');
                
                const currentDir = getCurrentDir();
                const items = Object.keys(currentDir).filter(name => 
                    showAll || !name.startsWith('.')
                ).sort();
                
                if (showDetails) {
                    items.forEach(item => {
                        const isDir = typeof currentDir[item] === 'object';
                        const perm = isDir ? 'drwxr-xr-x' : '-rw-r--r--';
                        const size = isDir ? '4096' : '1024';
                        const date = 'Oct 27 14:30';
                        addOutput(`${perm} 1 user user ${size} ${date} ${item}`, 'output-line');
                    });
                } else {
                    // Group items for better display
                    let output = '';
                    items.forEach((item, index) => {
                        const isDir = typeof currentDir[item] === 'object';
                        const className = isDir ? 'directory' : 'file';
                        output += `<span class="${className}">${item}</span>  `;
                        
                        if ((index + 1) % 4 === 0) {
                            addOutput(output, 'output-line');
                            output = '';
                        }
                    });
                    if (output) {
                        const line = document.createElement('div');
                        line.className = 'output-line';
                        line.innerHTML = output;
                        terminalOutput.appendChild(line);
                    }
                }
            },
            
            cd: (args) => {
                if (args.length === 0 || args[0] === '~') {
                    currentPath = ['home', 'user'];
                } else if (args[0] === '..') {
                    if (currentPath.length > 1) {
                        currentPath.pop();
                    }
                } else if (args[0].startsWith('/')) {
                    const pathParts = args[0].split('/').filter(p => p);
                    if (pathParts.length > 0) {
                        currentPath = pathParts;
                    }
                } else {
                    const targetDir = navigateToPath(args[0]);
                    if (targetDir && typeof targetDir === 'object') {
                        const pathParts = args[0].split('/').filter(p => p);
                        if (args[0].startsWith('/')) {
                            currentPath = pathParts;
                        } else {
                            currentPath = currentPath.concat(pathParts);
                        }
                    } else {
                        addOutput(`bash: cd: ${args[0]}: No such file or directory`, 'output-line error');
                        return;
                    }
                }
                updatePrompt();
            },
            
            cat: (args) => {
                if (args.length === 0) {
                    addOutput('cat: missing operand', 'output-line error');
                    return;
                }
                
                const path = args[0];
                const file = navigateToPath(path);
                
                if (file && typeof file === 'string') {
                    addOutput(file, 'output-line');
                } else {
                    addOutput(`cat: ${path}: No such file or directory`, 'output-line error');
                }
            },
            
            echo: (args) => {
                addOutput(args.join(' '), 'output-line');
            },
            
            date: () => {
                const now = new Date();
                addOutput(now.toString(), 'output-line');
            },
            
            uname: (args) => {
                if (args.includes('-a')) {
                    addOutput('Linux static-terminal 5.15.0-86-generic #96-Ubuntu SMP Wed Sep 20 08:23:49 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux', 'output-line');
                } else {
                    addOutput('Linux', 'output-line');
                }
            },
            
            lscpu: () => {
                addOutput('Architecture:          x86_64', 'output-line');
                addOutput('CPU op-mode(s):        32-bit, 64-bit', 'output-line');
                addOutput('CPU(s):                4', 'output-line');
                addOutput('Thread(s) per core:    2', 'output-line');
                addOutput('Core(s) per socket:    2', 'output-line');
                addOutput('Socket(s):             1', 'output-line');
                addOutput('Vendor ID:             GenuineIntel', 'output-line');
                addOutput('CPU family:            6', 'output-line');
                addOutput('Model:                 142', 'output-line');
            },
            
            uptime: () => {
                addOutput('14:30:45 up 2 days,  3:15,  1 user,  load average: 0.05, 0.10, 0.15', 'output-line');
            },
            
            free: (args) => {
                const humanReadable = args.includes('-h');
                const unit = humanReadable ? '' : 'Ki';
                
                addOutput(`              total        used        free      shared  buff/cache   available`, 'output-line');
                addOutput(`Mem:         15872${unit}B      8192${unit}B      4096${unit}B       512${unit}B      3584${unit}B      7168${unit}B`, 'output-line');
                addOutput(`Swap:         8192${unit}B         0${unit}B      8192${unit}B`, 'output-line');
            },
            
            'ip': (args) => {
                if (args[0] === 'addr') {
                    addOutput('1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000', 'output-line');
                    addOutput('    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00', 'output-line');
                    addOutput('    inet 127.0.0.1/8 scope host lo', 'output-line');
                    addOutput('       valid_lft forever preferred_lft forever', 'output-line');
                    addOutput('2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000', 'output-line');
                    addOutput('    link/ether 08:00:27:12:34:56 brd ff:ff:ff:ff:ff:ff', 'output-line');
                    addOutput('    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic eth0', 'output-line');
                    addOutput('       valid_lft 86388sec preferred_lft 86388sec', 'output-line');
                }
            },
            
            ifconfig: () => {
                addOutput('eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500', 'output-line');
                addOutput('        inet 192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255', 'output-line');
                addOutput('        inet6 fe80::a00:27ff:fe12:3456  prefixlen 64  scopeid 0x20<link>', 'output-line');
                addOutput('        ether 08:00:27:12:34:56  txqueuelen 1000  (Ethernet)', 'output-line');
                addOutput('        RX packets 123456  bytes 123456789 (117.7 MiB)', 'output-line');
                addOutput('        RX errors 0  dropped 0  overruns 0  frame 0', 'output-line');
                addOutput('        TX packets 98765  bytes 98765432 (94.2 MiB)', 'output-line');
                addOutput('        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0', 'output-line');
            },
            
            ping: (args) => {
                if (args.length === 0) {
                    addOutput('ping: usage error: Destination address required', 'output-line error');
                    return;
                }
                
                const target = args[0];
                addOutput(`PING ${target} (192.168.1.1) 56(84) bytes of data.`, 'output-line');
                
                // Simulate ping responses
                setTimeout(() => {
                    addOutput(`64 bytes from ${target} (192.168.1.1): icmp_seq=1 ttl=64 time=1.23 ms`, 'output-line');
                }, 500);
                
                setTimeout(() => {
                    addOutput(`64 bytes from ${target} (192.168.1.1): icmp_seq=2 ttl=64 time=1.45 ms`, 'output-line');
                }, 1000);
                
                setTimeout(() => {
                    addOutput(`64 bytes from ${target} (192.168.1.1): icmp_seq=3 ttl=64 time=1.12 ms`, 'output-line');
                    addOutput('', 'output-line');
                    addOutput(`--- ${target} ping statistics ---`, 'output-line');
                    addOutput('3 packets transmitted, 3 received, 0% packet loss, time 2002ms', 'output-line');
                    addOutput('rtt min/avg/max/mdev = 1.120/1.267/1.450/0.142 ms', 'output-line');
                }, 1500);
            },
            
            whoami: () => {
                addOutput('user', 'output-line');
            },
            
            sudo: (args) => {
                if (args.length === 0) {
                    addOutput('sudo: usage: sudo [-D level] -h | -K | -k | -V', 'output-line error');
                    addOutput('sudo: usage: sudo -v [-AknS] [-D level] [-g group] [-h host] [-p prompt] [-u user]', 'output-line error');
                    return;
                }
                
                if (args[0] === 'rm' && args.includes('-R') && args.includes('/')) {
                    addOutput('sudo: rm -R /: This is a dangerous operation! Aborting...', 'output-line error');
                    addOutput('Just kidding! This is a static terminal - no files were harmed.', 'output-line');
                } else {
                    addOutput(`sudo: ${args.join(' ')}: command executed with elevated privileges (simulated)`, 'output-line');
                }
            },
            
            exit: () => {
                addOutput('Logging out...', 'output-line');
                setTimeout(() => {
                    terminalOutput.innerHTML = '';
                    addOutput('Session terminated. Refresh page to start new session.', 'output-line');
                }, 1000);
            }
        };

        // Terminal control functions
        function closeTerminal() {
            if (confirm('Close terminal?')) {
                document.body.innerHTML = '<div style="padding: 20px; text-align: center;">Terminal closed. Refresh page to restart.</div>';
            }
        }
        
        function minimizeTerminal() {
            alert('Minimize functionality would be implemented in a real application.');
        }
        
        function maximizeTerminal() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        }

        // Initialize the terminal when the page loads
        document.addEventListener('DOMContentLoaded', initTerminal);
    </script>
</body>
</html>
